package com.cm4j.test.guava.consist;

import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.cm4j.test.guava.consist.entity.IEntity;
import com.cm4j.test.guava.consist.loader.CacheDes;
import com.cm4j.test.guava.consist.loader.CacheValueLoader;
import com.cm4j.test.guava.consist.value.IValue;
import com.google.common.cache.CacheBuilder;
import com.google.common.cache.LoadingCache;
import com.google.common.cache.RemovalListener;
import com.google.common.cache.RemovalNotification;

/**
 * 持久化缓存
 * 
 * <pre>
 * 读写分离：读取从guava cache中读取，在修改状态{@link CacheEntry#setDbState(DBState)}时
 * 同时增加到并发修改队列，从而写入独立于缓存
 * </pre>
 * 
 * @author Yang.hao
 * @since 2013-1-14 下午05:39:49
 * 
 */
public class CopyOfPersistCache {

	private static class Holder {
		public static final CopyOfPersistCache instance = new CopyOfPersistCache();
	}

	public static CopyOfPersistCache getInstance() {
		return Holder.instance;
	}

	private final Logger logger = LoggerFactory.getLogger(getClass());
	private final LoadingCache<String, IValue> cache;
	private final ConcurrentLinkedQueue<CacheEntryWrapper> updateQueue;
	private final ScheduledExecutorService service;

	public CopyOfPersistCache() {
		// 缓存初始化
		cache = CacheBuilder.newBuilder().expireAfterWrite(500, TimeUnit.SECONDS)
				.removalListener(new RemovalListener<String, IValue>() {
					@Override
					public void onRemoval(RemovalNotification<String, IValue> notification) {
						// TODO 缓存过期，但此时写入队列还未到库？
						// 此时再让其加入到缓存中

						// 或者由写入线程去让其过期 ?

						// 再或者从cache里面查不到则查更新队列里面的最后一个？
					}
				}).build(new CacheValueLoader());

		// 更新队列
		updateQueue = new ConcurrentLinkedQueue<CacheEntryWrapper>();

		// 定时处理器
		service = Executors.newScheduledThreadPool(1);
		service.scheduleAtFixedRate(new Runnable() {
			@Override
			public void run() {
				consumeUpdateQueue();
			}
		}, 10, 10, TimeUnit.SECONDS);
	}

	/**
	 * 获取，没有则加载
	 * 
	 * @param key
	 * @return
	 * @throws ExecutionException
	 *             loading时异常
	 */
	@SuppressWarnings("unchecked")
	public <V extends IValue> V get(CacheDes<V> desc) throws ExecutionException {
		return (V) cache.get(desc.getKey());
	}

	/**
	 * 获取，没有则返回null
	 * 
	 * @param key
	 * @return
	 * @throws ExecutionException
	 *             loading时异常
	 */
	@SuppressWarnings("unchecked")
	public <V extends IValue> V getIfPresent(CacheDes<V> desc) {
		return (V) cache.getIfPresent(desc.getKey());
	}

	public void stop() {
		// TODO
	}

	/**
	 * 发送到更新队列
	 * 
	 * @param entry
	 */
	void sendToUpdateQueue(CacheEntry entry) {
		entry.getNumInUpdateQueue().incrementAndGet();
		updateQueue.add(new CacheEntryWrapper(entry));
	}

	/**
	 * 将更新队列发送给db存储<br>
	 * 
	 */
	private void consumeUpdateQueue() {
		logger.warn("缓存定时存储数据，更新队列大小：{}", updateQueue.size());
		CacheEntryWrapper wrapper = null;
		while ((wrapper = updateQueue.poll()) != null) {
			CacheEntry entry = wrapper.getEntry();
			DBState dbState = wrapper.getDbState();

			int num = entry.getNumInUpdateQueue().decrementAndGet();
			// 删除或者更新的num为0
			if (DBState.D == dbState || num == 0) {
				IEntity entity = entry.parseEntity();
				if (entity != null) {
					// TODO 发送db去存储
					System.out.println(entry.getDbState());
				}
			}
		}
	}

	static class CacheEntryWrapper {
		private CacheEntry entry;
		private DBState dbState;

		private CacheEntryWrapper(CacheEntry entry) {
			this.entry = entry;
			// new 一个CacheEntryWrapper来保存每个entry的dbState
			this.dbState = entry.getDbState();
		}

		public CacheEntry getEntry() {
			return entry;
		}

		public DBState getDbState() {
			return dbState;
		}
	}
}
