package com.cm4j.test.guava.consist.entity;

import com.cm4j.test.guava.consist.CacheEntry;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.Table;

/**
 * TestTable generated by hbm2java
 */
@Entity
@Table(name = "test_table")
public class TestTable extends CacheEntry implements IEntity {

	private static final long serialVersionUID = 1L;

	private Integer NId;
	private Long NValue;

	public TestTable() {
	}

	public TestTable(Integer NId) {
		this.NId = NId;
	}

	public TestTable(Integer NId, Long NValue) {
		this.NId = NId;
		this.NValue = NValue;
	}

	@Id
	@Column(name = "n_id", unique = true, nullable = false)
	public Integer getNId() {
		return this.NId;
	}

	public void setNId(Integer NId) {
		this.NId = NId;
	}

	@Column(name = "n_value")
	public Long getNValue() {
		return this.NValue;
	}

	public void setNValue(Long NValue) {
		this.NValue = NValue;
	}

	@Override
	public IEntity parseEntity() {
		return this;
	}

	public synchronized void increaseValue() {
		this.NValue++;
		// 一般情况下是需要对NValue都要加锁
		// 但这里，也在synchronized锁下，所以getNValue()方法显示也正常
		// System.out.println("TestTable value+1:" + this);
	}

	@Override
	public String toString() {
		return this.getClass().getSimpleName() + ":" + this.hashCode() + "#" + getNId() + "-" + getNValue();
	}
}
